barrier_set_t::barrier_set_t(shader_core_ctx *shader,unsigned max_warps_per_core, unsigned max_cta_per_core, unsigned max_barriers_per_cta, unsigned warp_size)
{
   m_max_warps_per_core = max_warps_per_core;
   m_max_cta_per_core = max_cta_per_core;
   m_max_barriers_per_cta = max_barriers_per_cta;
   m_warp_size = warp_size;
   m_shader = shader;
   if( max_warps_per_core > WARP_PER_CTA_MAX ) {
      printf("ERROR ** increase WARP_PER_CTA_MAX in shader.h from %u to >= %u or warps per cta in gpgpusim.config\n",
             WARP_PER_CTA_MAX, max_warps_per_core );
      exit(1);
   }
   if(max_barriers_per_cta > MAX_BARRIERS_PER_CTA){
	   printf("ERROR ** increase MAX_BARRIERS_PER_CTA in abstract_hardware_model.h from %u to >= %u or barriers per cta in gpgpusim.config\n",
			   MAX_BARRIERS_PER_CTA, max_barriers_per_cta );
	   exit(1);
   }
   m_warp_active.reset();
   m_warp_at_barrier.reset();
   for(unsigned i=0; i<max_barriers_per_cta; i++){
	   m_bar_id_to_warps[i].reset();
   }
}

// during cta allocation
void barrier_set_t::allocate_barrier( unsigned cta_id, warp_set_t warps )
{
   assert( cta_id < m_max_cta_per_core );
   cta_to_warp_t::iterator w=m_cta_to_warps.find(cta_id);
   assert( w == m_cta_to_warps.end() ); // cta should not already be active or allocated barrier resources
   m_cta_to_warps[cta_id] = warps;
   assert( m_cta_to_warps.size() <= m_max_cta_per_core ); // catch cta's that were not properly deallocated
  
   m_warp_active |= warps;
   m_warp_at_barrier &= ~warps;
   for(unsigned i=0; i<m_max_barriers_per_cta; i++){
	   m_bar_id_to_warps[i] &=~warps;
   }

}

// during cta deallocation
void barrier_set_t::deallocate_barrier( unsigned cta_id )
{
   cta_to_warp_t::iterator w=m_cta_to_warps.find(cta_id);
   if( w == m_cta_to_warps.end() )
      return;
   warp_set_t warps = w->second;
   warp_set_t at_barrier = warps & m_warp_at_barrier;
   assert( at_barrier.any() == false ); // no warps stuck at barrier
   warp_set_t active = warps & m_warp_active;
   assert( active.any() == false ); // no warps in CTA still running
   m_warp_active &= ~warps;
   m_warp_at_barrier &= ~warps;

   for(unsigned i=0; i<m_max_barriers_per_cta; i++){
	   warp_set_t at_a_specific_barrier = warps & m_bar_id_to_warps[i];
	   assert( at_a_specific_barrier.any() == false ); // no warps stuck at barrier
	   m_bar_id_to_warps[i] &=~warps;
   }
   m_cta_to_warps.erase(w);
}

// individual warp hits barrier
void barrier_set_t::warp_reaches_barrier(unsigned cta_id,unsigned warp_id,warp_inst_t* inst)
{
	barrier_type bar_type = inst->bar_type;
	unsigned bar_id = inst->bar_id;
	unsigned bar_count = inst->bar_count;
	assert(bar_id!=(unsigned)-1);
   cta_to_warp_t::iterator w=m_cta_to_warps.find(cta_id);

   if( w == m_cta_to_warps.end() ) { // cta is active
      printf("ERROR ** cta_id %u not found in barrier set on cycle %llu+%llu...\n", cta_id, gpu_tot_sim_cycle, gpu_sim_cycle );
      dump();
      abort();
   }
   assert( w->second.test(warp_id) == true ); // warp is in cta

   m_bar_id_to_warps[bar_id].set(warp_id);
   if(bar_type==SYNC || bar_type==RED){
	   m_warp_at_barrier.set(warp_id);
   }
   warp_set_t warps_in_cta = w->second;
   warp_set_t at_barrier = warps_in_cta & m_bar_id_to_warps[bar_id];
   warp_set_t active = warps_in_cta & m_warp_active;
   if(bar_count==(unsigned)-1){
	   if( at_barrier == active ) {
		   // all warps have reached barrier, so release waiting warps...
		   m_bar_id_to_warps[bar_id] &= ~at_barrier;
		   m_warp_at_barrier &= ~at_barrier;
		   if(bar_type==RED){
			   m_shader->broadcast_barrier_reduction(cta_id, bar_id,at_barrier);
		   }
	   }
  }else{
	  // TODO: check on the hardware if the count should include warp that exited
	  if ((at_barrier.count() * m_warp_size) == bar_count){
		   // required number of warps have reached barrier, so release waiting warps...
		   m_bar_id_to_warps[bar_id] &= ~at_barrier;
		   m_warp_at_barrier &= ~at_barrier;
		   if(bar_type==RED){
			   m_shader->broadcast_barrier_reduction(cta_id, bar_id,at_barrier);
		   }
	  }
  }


}

// warp reaches exit 
void barrier_set_t::warp_exit( unsigned warp_id )
{
   // caller needs to verify all threads in warp are done, e.g., by checking PDOM stack to 
   // see it has only one entry during exit_impl()
   m_warp_active.reset(warp_id);

   // test for barrier release 
   cta_to_warp_t::iterator w=m_cta_to_warps.begin(); 
   for (; w != m_cta_to_warps.end(); ++w) {
      if (w->second.test(warp_id) == true) break; 
   }
   warp_set_t warps_in_cta = w->second;
   warp_set_t active = warps_in_cta & m_warp_active;

   for(unsigned i=0; i<m_max_barriers_per_cta; i++){
	   warp_set_t at_a_specific_barrier = warps_in_cta & m_bar_id_to_warps[i];
	   if( at_a_specific_barrier == active ) {
	      // all warps have reached barrier, so release waiting warps...
		   m_bar_id_to_warps[i] &= ~at_a_specific_barrier;
		   m_warp_at_barrier &= ~at_a_specific_barrier;
	   }
   }
}

// assertions
bool barrier_set_t::warp_waiting_at_barrier( unsigned warp_id ) const
{ 
   return m_warp_at_barrier.test(warp_id);
}

void barrier_set_t::dump()
{
   printf( "barrier set information\n");
   printf( "  m_max_cta_per_core = %u\n",  m_max_cta_per_core );
   printf( "  m_max_warps_per_core = %u\n", m_max_warps_per_core );
   printf( " m_max_barriers_per_cta =%u\n", m_max_barriers_per_cta);
   printf( "  cta_to_warps:\n");
   
   cta_to_warp_t::const_iterator i;
   for( i=m_cta_to_warps.begin(); i!=m_cta_to_warps.end(); i++ ) {
      unsigned cta_id = i->first;
      warp_set_t warps = i->second;
      printf("    cta_id %u : %s\n", cta_id, warps.to_string().c_str() );
   }
   printf("  warp_active: %s\n", m_warp_active.to_string().c_str() );
   printf("  warp_at_barrier: %s\n", m_warp_at_barrier.to_string().c_str() );
   for( unsigned i=0; i<m_max_barriers_per_cta; i++){
	   warp_set_t warps_reached_barrier = m_bar_id_to_warps[i];
	   printf("  warp_at_barrier %u: %s\n", i, warps_reached_barrier.to_string().c_str() );
   }
   fflush(stdout); 
}
