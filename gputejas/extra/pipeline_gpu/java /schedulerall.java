class lrr_scheduler : public scheduler_unit {
    public:
        lrr_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,
                        Scoreboard* scoreboard, simt_stack** simt,
                        std::vector<shd_warp_t>* warp,
                        register_set* sp_out,
                        register_set* sfu_out,
                        register_set* mem_out,
                        int id )
        : scheduler_unit ( stats, shader, scoreboard, simt, warp, sp_out, sfu_out, mem_out, id ){}
        virtual ~lrr_scheduler () {}
        virtual void order_warps ();
        virtual void done_adding_supervised_warps() {
            m_last_supervised_issued = m_supervised_warps.end();
        }
    };
    
    class gto_scheduler : public scheduler_unit {
    public:
        gto_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,
                        Scoreboard* scoreboard, simt_stack** simt,
                        std::vector<shd_warp_t>* warp,
                        register_set* sp_out,
                        register_set* sfu_out,
                        register_set* mem_out,
                        int id )
        : scheduler_unit ( stats, shader, scoreboard, simt, warp, sp_out, sfu_out, mem_out, id ){}
        virtual ~gto_scheduler () {}
        virtual void order_warps ();
        virtual void done_adding_supervised_warps() {
            m_last_supervised_issued = m_supervised_warps.begin();
        }
    
    };
    
    
    class two_level_active_scheduler : public scheduler_unit {
    public:
        two_level_active_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,
                              Scoreboard* scoreboard, simt_stack** simt,
                              std::vector<shd_warp_t>* warp,
                              register_set* sp_out,
                              register_set* sfu_out,
                              register_set* mem_out,
                              int id,
                              char* config_str )
        : scheduler_unit ( stats, shader, scoreboard, simt, warp, sp_out, sfu_out, mem_out, id ),
          m_pending_warps() 
        {
            unsigned inner_level_readin;
            unsigned outer_level_readin; 
            int ret = sscanf( config_str,
                              "two_level_active:%d:%d:%d",
                              &m_max_active_warps,
                              &inner_level_readin,
                              &outer_level_readin);
            assert( 3 == ret );
            m_inner_level_prioritization=(scheduler_prioritization_type)inner_level_readin;
            m_outer_level_prioritization=(scheduler_prioritization_type)outer_level_readin;
        }
        virtual ~two_level_active_scheduler () {}
        virtual void order_warps();
        void add_supervised_warp_id(int i) {
            if ( m_next_cycle_prioritized_warps.size() < m_max_active_warps ) {
                m_next_cycle_prioritized_warps.push_back( &warp(i) );
            } else {
                m_pending_warps.push_back(&warp(i));
            }
        }
        virtual void done_adding_supervised_warps() {
            m_last_supervised_issued = m_supervised_warps.begin();
        }
    
    protected:
        virtual void do_on_warp_issued( unsigned warp_id,
                                        unsigned num_issued,
                                        const std::vector< shd_warp_t* >::const_iterator& prioritized_iter );
    
    private:
        std::deque< shd_warp_t* > m_pending_warps;
        scheduler_prioritization_type m_inner_level_prioritization;
        scheduler_prioritization_type m_outer_level_prioritization;
        unsigned m_max_active_warps;
    };
    
    // Static Warp Limiting Scheduler
    class swl_scheduler : public scheduler_unit {
    public:
        swl_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,
                        Scoreboard* scoreboard, simt_stack** simt,
                        std::vector<shd_warp_t>* warp,
                        register_set* sp_out,
                        register_set* sfu_out,
                        register_set* mem_out,
                        int id,
                        char* config_string );
        virtual ~swl_scheduler () {}
        virtual void order_warps ();
        virtual void done_adding_supervised_warps() {
            m_last_supervised_issued = m_supervised_warps.begin();
        }
    
    protected:
        scheduler_prioritization_type m_prioritization;
        unsigned m_num_warps_to_limit;
    };
    

    void lrr_scheduler::order_warps()
    {
        order_lrr( m_next_cycle_prioritized_warps,
                   m_supervised_warps,
                   m_last_supervised_issued,
                   m_supervised_warps.size() );
    }
    
    void gto_scheduler::order_warps()
    {
        order_by_priority( m_next_cycle_prioritized_warps,
                           m_supervised_warps,
                           m_last_supervised_issued,
                           m_supervised_warps.size(),
                           ORDERING_GREEDY_THEN_PRIORITY_FUNC,
                           scheduler_unit::sort_warps_by_oldest_dynamic_id );
    }
    
    void
    two_level_active_scheduler::do_on_warp_issued( unsigned warp_id,
                                                   unsigned num_issued,
                                                   const std::vector< shd_warp_t* >::const_iterator& prioritized_iter )
    {
        scheduler_unit::do_on_warp_issued( warp_id, num_issued, prioritized_iter );
        if ( SCHEDULER_PRIORITIZATION_LRR == m_inner_level_prioritization ) {
            std::vector< shd_warp_t* > new_active; 
            order_lrr( new_active,
                       m_next_cycle_prioritized_warps,
                       prioritized_iter,
                       m_next_cycle_prioritized_warps.size() );
            m_next_cycle_prioritized_warps = new_active;
        } else {
            fprintf( stderr,
                     "Unimplemented m_inner_level_prioritization: %d\n",
                     m_inner_level_prioritization );
            abort();
        }
    }
    
    void two_level_active_scheduler::order_warps()
    {
        //Move waiting warps to m_pending_warps
        unsigned num_demoted = 0;
        for (   std::vector< shd_warp_t* >::iterator iter = m_next_cycle_prioritized_warps.begin();
                iter != m_next_cycle_prioritized_warps.end(); ) {
            bool waiting = (*iter)->waiting();
            for (int i=0; i<4; i++){
                const warp_inst_t* inst = (*iter)->ibuffer_next_inst();
                //Is the instruction waiting on a long operation?
                if ( inst && inst->in[i] > 0 && this->m_scoreboard->islongop((*iter)->get_warp_id(), inst->in[i])){
                    waiting = true;
                }
            }
    
            if( waiting ) {
                m_pending_warps.push_back(*iter);
                iter = m_next_cycle_prioritized_warps.erase(iter);
                SCHED_DPRINTF( "DEMOTED warp_id=%d, dynamic_warp_id=%d\n",
                               (*iter)->get_warp_id(),
                               (*iter)->get_dynamic_warp_id() );
                ++num_demoted;
            } else {
                ++iter;
            }
        }
    
        //If there is space in m_next_cycle_prioritized_warps, promote the next m_pending_warps
        unsigned num_promoted = 0;
        if ( SCHEDULER_PRIORITIZATION_SRR == m_outer_level_prioritization ) {
            while ( m_next_cycle_prioritized_warps.size() < m_max_active_warps ) {
                m_next_cycle_prioritized_warps.push_back(m_pending_warps.front());
                m_pending_warps.pop_front();
                SCHED_DPRINTF( "PROMOTED warp_id=%d, dynamic_warp_id=%d\n",
                               (m_next_cycle_prioritized_warps.back())->get_warp_id(),
                               (m_next_cycle_prioritized_warps.back())->get_dynamic_warp_id() );
                ++num_promoted;
            }
        } else {
            fprintf( stderr,
                     "Unimplemented m_outer_level_prioritization: %d\n",
                     m_outer_level_prioritization );
            abort();
        }
        assert( num_promoted == num_demoted );
    }
    
    swl_scheduler::swl_scheduler ( shader_core_stats* stats, shader_core_ctx* shader,
                                   Scoreboard* scoreboard, simt_stack** simt,
                                   std::vector<shd_warp_t>* warp,
                                   register_set* sp_out,
                                   register_set* sfu_out,
                                   register_set* mem_out,
                                   int id,
                                   char* config_string )
        : scheduler_unit ( stats, shader, scoreboard, simt, warp, sp_out, sfu_out, mem_out, id )
    {
        unsigned m_prioritization_readin;
        int ret = sscanf( config_string,
                          "warp_limiting:%d:%d",
                          &m_prioritization_readin,
                          &m_num_warps_to_limit
                         );
        assert( 2 == ret );
        m_prioritization = (scheduler_prioritization_type)m_prioritization_readin;
        // Currently only GTO is implemented
        assert( m_prioritization == SCHEDULER_PRIORITIZATION_GTO );
        assert( m_num_warps_to_limit <= shader->get_config()->max_warps_per_shader );
    }
    
    void swl_scheduler::order_warps()
    {
        if ( SCHEDULER_PRIORITIZATION_GTO == m_prioritization ) {
            order_by_priority( m_next_cycle_prioritized_warps,
                               m_supervised_warps,
                               m_last_supervised_issued,
                               MIN( m_num_warps_to_limit, m_supervised_warps.size() ),
                               ORDERING_GREEDY_THEN_PRIORITY_FUNC,
                               scheduler_unit::sort_warps_by_oldest_dynamic_id );
        } else {
            fprintf(stderr, "swl_scheduler m_prioritization = %d\n", m_prioritization);
            abort();
        }
    }
        